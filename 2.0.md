# ðŸ“„ TSD â€” Account Service

## Iteration 2.0: Atomic Debit + Game Action

**Status:** Planned (Design Only)
**Owner:** Account Service + Game Orchestrator
**Depends on:** Iteration 1.5 (Balance Snapshot)

---

## 1. Purpose

Iteration 2.0 ensures that **monetary debits and game actions are committed atomically**.

This prevents inconsistent states where:

* balance is deducted but game action fails
* game action succeeds without payment
* retries cause double-spend or double-entry

---

## 2. Problem Statement

### Without 2.0

```
Game â†’ DebitPoints
Game â†’ CreateMatch / JoinRoom
```

Failure between these steps can cause:

* user charged but not entered
* duplicate debits on retry
* manual reconciliation

---

### With 2.0

```
[ Debit + Game Action ] â†’ committed as ONE transaction
```

All-or-nothing.

---

## 3. Scope

### In Scope

* Atomic debit + domain action
* Idempotent retries
* Shared transaction boundary

### Out of Scope (Explicitly)

* Reservations / holds
* Refunds / reversals
* Async settlement
* Rollbacks beyond transaction
* Multi-step workflows

---

## 4. Core Design Principle

> **Money moves only when game state moves.**

If game state cannot be written â†’ **no debit**
If debit cannot be written â†’ **no game state**

---

## 5. Architectural Model

### 5.1 Transaction Owner

The **caller** (Game Orchestrator or Game Service) owns the transaction.

The Account Service exposes **transaction-safe helpers**, not standalone debit.

---

### 5.2 New Capability

```ts
DebitWithAction
```

This is a **pattern**, not a public API.

---

## 6. Data Model Additions

### 6.1 Game Action Marker (Minimal)

```ts
game_actions/{actionId} {
  accountId: string
  gameId: string
  type: "ENTRY_FEE" | "BUY_IN"
  amount: number
  referenceId: string
  createdAt: Timestamp
}
```

* Written inside same transaction as debit
* Used only for idempotency + audit

---

## 7. Idempotency Model

### Key Rule

`referenceId` must be **shared** between:

* ledger entry
* game action entry

Retry behavior:

* if `referenceId` exists â†’ no-op
* transaction exits safely

---

## 8. Transaction Flow (Canonical)

```ts
db.runTransaction(async (tx) => {
  // 1. Read account snapshot
  // 2. Validate balance
  // 3. Check idempotency (ledger + action)
  // 4. Write DEBIT ledger
  // 5. Update balanceSnapshot
  // 6. Write game action
});
```

Failure anywhere â†’ nothing committed.

---

## 9. Error Semantics

| Condition             | Outcome           |
| --------------------- | ----------------- |
| Insufficient balance  | Abort transaction |
| Duplicate referenceId | No-op             |
| Game state conflict   | Abort transaction |
| Network retry         | Safe              |

---

## 10. Security & Ownership

* Clients **never** call DebitWithAction
* Only backend services
* Game Orchestrator validates:

  * game rules
  * user eligibility
  * pricing

Wallet only enforces **financial correctness**.

---

## 11. Consistency Guarantees

| Property            | Guaranteed |
| ------------------- | ---------- |
| No double-spend     | âœ…          |
| No unpaid entry     | âœ…          |
| Retry safe          | âœ…          |
| Ledger auditability | âœ…          |

---

## 12. Migration / Compatibility

* Iteration 1.5 APIs remain unchanged
* DebitPoints still usable for:

  * admin debit
  * instant actions
* 2.0 used **only when required**

---

## 13. Completion Criteria

Iteration 2.0 is **design-complete** when:

* Atomic pattern is documented
* Game Orchestrator contract defined
* No new wallet state added
* No breaking changes introduced
